/*
 * Copyright Aduna (http://www.aduna-software.com/) (c) 1997-2007.
 *
 * Licensed under the Aduna BSD-style license.
 */

/*
 * SPARQL JJTree input file for JavaCC, a Java Compiler Compiler. JavaCC can be
 * downloaded from https://javacc.dev.java.net/
 *
 * author: Arjohn Kampman
 */

options {
	MULTI=true;
	VISITOR=true;
	VISITOR_EXCEPTION="VisitorException";
	STATIC=false;
	UNICODE_INPUT=true;
	JAVA_UNICODE_ESCAPE=true; // pre-process unicode escapes, see section A.2 of spec
}

PARSER_BEGIN(SyntaxTreeBuilder)

package org.openrdf.query.parser.sparql.ast;

import java.io.StringReader;

import org.openrdf.model.URI;
import org.openrdf.model.vocabulary.RDF;
import org.openrdf.model.vocabulary.XMLSchema;
import org.openrdf.query.algebra.Compare.CompareOp;
import org.openrdf.query.algebra.MathExpr.MathOp;

public class SyntaxTreeBuilder {

	/**
	 * Parses the supplied SPARQL query and builds a syntax tree from it.
	 *
	 * @param query A SPARQL query string.
	 * @return The root of the syntax tree.
	 * @throws TokenMgrError If the query was syntactically incorrect.
	 * @throws ParseException If the query was syntactically incorrect.
	 */
	public static ASTQueryContainer parseQuery(String query)
		throws TokenMgrError, ParseException
	{
		SyntaxTreeBuilder stb = new SyntaxTreeBuilder( new StringReader(query) );
		return stb.QueryContainer();
	}

	/**
	 * Parses the supplied SPARQL update sequence and builds a syntax tree from it.
	 *
	 * @param sequence A SPARQL update sequence string.
	 * @return The root of the syntax tree.
	 * @throws TokenMgrError If the update sequence was syntactically incorrect.
	 * @throws ParseException If the update sequence was syntactically incorrect.
	 */
	public static ASTUpdateSequence parseUpdateSequence(String sequence)
		throws TokenMgrError, ParseException
	{
		SyntaxTreeBuilder stb = new SyntaxTreeBuilder( new StringReader(sequence) );
		return stb.UpdateSequence();
	}
	
	/**
	 * Trims <tt>n</tt> character from the start and end of the supplied string.
	 */
	private static String _trimString(String s, int n) {
		if (s.length() >= 2 * n) {
			s = s.substring(n, s.length() - n);
		}
		return s;
	}

	/**
	 * Append the image of the  provided token to the supplied StringBuilder.
	 * @param sb the StringBuilder to append to. May be null.
	 */
	private static void appendToken(StringBuilder sb, Token t) {
	    if (sb != null) {
		sb.append(t.image);
		sb.append(" ");
	    }
	}
}
PARSER_END(SyntaxTreeBuilder)

//
// tokens
//

TOKEN :
{
	// Whitespace characters
	<#WS_CHAR: " " | "\t" | "\n" | "\r" | "\f">
}

SKIP :
{
	<WHITESPACE: <WS_CHAR>>
}

SPECIAL_TOKEN :
{
	<SINGLE_LINE_COMMENT: "#" (~["\n","\r"])*>
}

// Special characters
TOKEN :
{
	<LPAREN: "(">
|	<RPAREN: ")">
|	<LBRACE: "{">
|	<RBRACE: "}">
|	<LBRACK: "[">
|	<RBRACK: "]">
|	<SEMICOLON: ";">
|	<COMMA: ",">
|	<DOT: ".">
|	<EQ: "=">
|	<NE: "!=">
|	<GT: ">">
|	<LT: "<">
|	<LE: "<=">
|	<GE: ">=">
|	<NOT: "!">
|	<OR: "||">
|	<AND: "&&">
|	<PLUS: "+">
|	<MINUS: "-">
|	<STAR: "*">
|	<QUESTION: "?">
|	<SLASH: "/">
|       <PIPE: "|">
|	<INVERSE: "^">
|	<DT_PREFIX: "^^">
|	<NIL: <LPAREN> (<WS_CHAR>)* <RPAREN>>
|	<ANON: <LBRACK> (<WS_CHAR>)* <RBRACK>>
}

TOKEN :
{
	<IS_A: "a"> // Note: case-sensitive!
}

TOKEN [IGNORE_CASE] :
{
	<BASE: "base">
|	<PREFIX: "prefix">
|	<SELECT: "select">
|	<CONSTRUCT: "construct">
|	<DESCRIBE: "describe">
|	<ASK: "ask">
|	<DISTINCT: "distinct">
|	<REDUCED: "reduced">
|	<AS: "as">
|	<FROM: "from">
|	<NAMED: "named">
|	<WHERE: "where">
|	<ORDER: "order">
|	<GROUP: "group">
|	<BY: "by">
|	<ASC: "asc">
|	<DESC: "desc">
|	<LIMIT: "limit">
|	<OFFSET: "offset">
|	<OPTIONAL: "optional">
|	<GRAPH: "graph">
|	<UNION: "union">
|	<MINUS_SETOPER: "minus">
|	<FILTER: "filter">
|	<HAVING: "having">
|	<EXISTS: "exists">
|	<NOT_EXISTS: "not exists">
|	<STR: "str">
|	<LANG: "lang">
|	<LANGMATCHES: "langmatches">
|	<DATATYPE: "datatype">
|	<BOUND: "bound">
|	<SAMETERM: "sameTerm">
|	<IS_IRI: ("isIRI"|"isURI")>
|	<IS_BLANK: "isBlank">
|	<IS_LITERAL: "isLiteral">
|	<IS_NUMERIC: "isNumeric">
|	<COALESCE: "coalesce">
|	<BNODE: "bnode">
|	<STRDT: "strdt">
|	<STRLANG: "strlang">
|	<IRI: "IRI"|"URI">
|	<IF: "if">
|	<IN: "in">
|	<NOT_IN: "not in">
|	<COUNT: "count">
|	<SUM: "sum">
|	<MIN: "min">
|	<MAX: "max">
|	<AVG: "avg">
|	<SAMPLE: "sample">
|	<GROUP_CONCAT: "group_concat">
|	<SEPARATOR: "separator">
|	<REGEX: "regex">
|	<TRUE: "true">
|	<FALSE: "false">
|	<BIND: "bind">
|	<SERVICE: "service">
|	<BINDINGS: "bindings">
|	<UNDEF: "UNDEF">
|	<STRLEN: "strlen">
|	<SUBSTR: "substr">
|	<STR_STARTS: "strStarts">
|	<STR_ENDS: "strEnds">
|	<UCASE: "ucase">
|	<LCASE: "lcase">
|	<CONCAT: "concat">
|	<CONTAINS: "contains">
|	<ENCODE_FOR_URI: "encode_for_URI">
|	<RAND: "rand">
|	<ABS: "abs">
|	<CEIL: "ceil">
|	<FLOOR: "floor">
|	<ROUND: "round">
|	<NOW: "now">
|	<YEAR: "year">
|	<MONTH: "month">
|	<DAY: "day">
|	<HOURS: "hours">
|	<MINUTES: "minutes">
|	<SECONDS: "seconds">
|	<TIMEZONE: "timezone">
|	<TZ: "tz">
|	<MD5: "md5">
|	<SHA1: "sha1">
|	<SHA224: "sha224">
|	<SHA256: "sha256">
|	<SHA384: "sha384">
|	<SHA512: "sha512">
}

TOKEN [IGNORE_CASE] :	// SPARQL 1.1 Update-specific tokens
{
	<LOAD: "load">
|	<CLEAR: "clear">
|	<DROP: "drop">
|	<ADD: "add">
|	<MOVE: "move">
|	<COPY: "copy">
|	<CREATE: "create">
|	<INSERT: "insert">
|	<DATA: "data">
|	<DELETE: "delete">
|	<WITH: "with">
|	<SILENT: "silent">
|	<DEFAULT_GRAPH: "default">
|	<ALL: "all">
|	<INTO: "into">
|	<TO: "to">
|	<USING: "using">
}

TOKEN:
{
	<Q_IRI_REF: "<" (~["<", ">", "\"", "{", "}", "|", "^", "`", "\\", "\u0000"-"\u0020"])* ">">

|	<PNAME_NS: (<PN_PREFIX>)? ":">
|	<PNAME_LN: (<PN_PREFIX>)? ":" <PN_LOCAL>> // Note: PN_LOCAL not optional, case handled by PNAME_NS

|	<BLANK_NODE_LABEL: "_:" <PN_LOCAL>>

|	<VAR1: "?" <VARNAME>>
|	<VAR2: "$" <VARNAME>>
|	<LANGTAG: "@" (<ALPHA>)+ ("-" (<ALPHA>|<NUM>)+)*>
|	<INTEGER: (<NUM>)+>
|	<INTEGER_POSITIVE: "+" <INTEGER>>
|	<INTEGER_NEGATIVE: "-" <INTEGER>>
|	<DECIMAL: (<DECIMAL1>|<DECIMAL2>)>
|	<#DECIMAL1: (<NUM>)+ "." (<NUM>)*>
|	<#DECIMAL2: "." (<NUM>)+>
|	<DECIMAL_POSITIVE: "+" <DECIMAL>>
|	<DECIMAL_NEGATIVE: "-" <DECIMAL>>
|	<DOUBLE: (<DOUBLE1>|<DOUBLE2>|<DOUBLE3>)>
|	<#DOUBLE1: (<NUM>)+ "." (<NUM>)* <EXPONENT>>
|	<#DOUBLE2: "." (<NUM>)+ <EXPONENT>>
|	<#DOUBLE3: (<NUM>)+ <EXPONENT>>
|	<#EXPONENT: ["e","E"] (["+","-"])? (<NUM>)+>
|	<DOUBLE_POSITIVE: "+" <DOUBLE>>
|	<DOUBLE_NEGATIVE: "-" <DOUBLE>>
|	<STRING_LITERAL1: "'" (<SAFE_CHAR1>|<ECHAR>)* "'">
|	<STRING_LITERAL2: "\"" (<SAFE_CHAR2>|<ECHAR>)* "\"">
|	<STRING_LITERAL_LONG1: "'''" ( ("'"|"''")? (<SAFE_CHAR_LONG1>|<ECHAR>) )* "'''">
|	<STRING_LITERAL_LONG2: "\"\"\"" ( ("\""|"\"\"")? (<SAFE_CHAR_LONG2>|<ECHAR>) )* "\"\"\"">
|	<#SAFE_CHAR1: (~["'", "\\", "\r", "\n"])>
|	<#SAFE_CHAR2: (~["\"", "\\", "\r", "\n"])>
|	<#SAFE_CHAR_LONG1: (~["'","\\"])>
|	<#SAFE_CHAR_LONG2: (~["\"","\\"])>
|	<#ECHAR: "\\" ["t", "b", "n", "r", "f", "\\", "\"", "'"]>
|	<#HEX: ["0"-"9"] | ["A"-"F"] | ["a"-"f"]>
|	<#ALPHA: ["a"-"z","A"-"Z"]>
|	<#NUM: ["0"-"9"]>
}

TOKEN:
{
	<#PN_CHARS_BASE:
	    <ALPHA> | ["\u00C0"-"\u00D6"] | ["\u00D8"-"\u00F6"] | ["\u00F8"-"\u02FF"] | ["\u0370"-"\u037D"]
	  | ["\u037F"-"\u1FFF"] | ["\u200C"-"\u200D"] | ["\u2070"-"\u218F"] | ["\u2C00"-"\u2FEF"]
	  | ["\u3001"-"\uD7FF"] | ["\uF900"-"\uFDCF"] | ["\uFDF0"-"\uFFFD"]
	  // | ["\u10000"-"\uEFFFF"] FIXME: JavaCC/Java can't handle this?
	>
|	<#PN_CHARS_U: <PN_CHARS_BASE> | "_">
|	<#PN_START_CHAR: <PN_CHARS_U> | <NUM>>
|	<#VAR_CHAR: <PN_START_CHAR> | "\u00B7" | ["\u0300"-"\u036F"] | ["\u203F"-"\u2040"]>
|	<#PN_END_CHAR: <VAR_CHAR> | "-">
|	<#PN_CHAR: <PN_END_CHAR> | ".">

|	<#PN_PREFIX: <PN_CHARS_BASE> ( (<PN_CHAR>)* <PN_END_CHAR> )?>
|	<#PN_LOCAL: <PN_START_CHAR> ( (<PN_CHAR>)* <PN_END_CHAR> )?>
|	<#VARNAME: <PN_START_CHAR> (<VAR_CHAR>)*>
}

//
// grammar
//

ASTUpdateSequence UpdateSequence():
{}
{
    UpdateContainer() ( <SEMICOLON> UpdateContainer() )* <EOF>
    { return jjtThis; }
}

ASTUpdateContainer UpdateContainer():
{}
{
    Prolog() Update()
    { return jjtThis; }
}

ASTQueryContainer QueryContainer():
{}
{
	Prolog() Query() <EOF>
	{ return jjtThis; }
}

void Prolog() #void :
{}
{
	[ BaseDecl() ] ( PrefixDecl() )*
}

void BaseDecl() :
{ Token t; }
{
	<BASE> t = <Q_IRI_REF> {jjtThis.setIRI(_trimString(t.image, 1));}
}

void PrefixDecl() :
{ Token prefix; }
{
	<PREFIX> prefix = <PNAME_NS> IRI(null)
	{
		// Remove trailing colon from prefix
		String prefixStr = prefix.image;
		prefixStr = prefixStr.substring(0, prefixStr.length() - 1);

		jjtThis.setPrefix(prefixStr);
	}
}


void Query() #void :
{}
{
    (SelectQuery(null) | ConstructQuery(null) |	DescribeQuery(null) | AskQuery(null)) }

void SelectQuery(StringBuilder sb) :
{}
{
	Select(sb)
	( DatasetClause(sb) )*
	WhereClause(sb)
	SolutionModifier(sb)
	[BindingsClause(sb)]
}

void Select(StringBuilder sb) :
{ Token t; }
{
	t = <SELECT> { appendToken(sb, t); }
	[
		<DISTINCT> {jjtThis.setDistinct(true); appendToken(sb, t); }
	|
		<REDUCED> {jjtThis.setReduced(true); appendToken(sb, t); }
	]

	(
		<STAR> { jjtThis.setWildcard(true); appendToken(sb, t); }
	|
		( ProjectionElem(sb) )+ 
	)
}

void ProjectionElem(StringBuilder sb) :
{Token t; }
{
    Var(sb)
    |
    LParen(sb)
	Expression(sb) 
	t = <AS> { appendToken(sb, t); }
	Var(sb)
    RParen(sb)
}

void ConstructQuery(StringBuilder sb) :
{}
{
	Construct(sb)
	( DatasetClause(sb) )*
	WhereClause(sb)
	SolutionModifier(sb)
	[BindingsClause(sb)]
}

void Construct(StringBuilder sb) :
{Token t;}
{	
	t = <CONSTRUCT> { appendToken(sb, t); }
	[ LOOKAHEAD(2) ConstructClause(sb) ]
	
}

void ConstructClause(StringBuilder sb) #void :
{Token t;}
{
    // Note: replaced ConstructTriples ref with equivalent TriplesBlock ref
    t = <LBRACE> { appendToken(sb, t); }
	[ TriplesBlock(sb) ] 
    t = <RBRACE> { appendToken(sb, t); }
}

void DescribeQuery(StringBuilder sb) :
{}
{
	Describe(sb)
	( DatasetClause(sb) )*
	[ WhereClause(sb) ]
	SolutionModifier(sb)
	[BindingsClause(sb)]
}

void Describe(StringBuilder sb) :
{Token t;}
{
	t = <DESCRIBE> { appendToken(sb, t); }
	(
		t = <STAR> { appendToken(sb, t); jjtThis.setWildcard(true); }
	|
		( VarOrIRIref(sb) )+
	)
}

void AskQuery(StringBuilder sb) :
{Token t;}
{
	t = <ASK> { appendToken(sb, t); }
	( DatasetClause(sb) )*
	WhereClause(sb)
	[BindingsClause(sb)]
}

void DatasetClause(StringBuilder sb) :
{ Token t; }
{
	t = <FROM> { appendToken(sb, t); }
	[ t = <NAMED> { appendToken(sb, t); jjtThis.setNamed(true);}] 
	IRIref(sb)
}

void WhereClause(StringBuilder sb) :
{ Token t; }
{
	 [ t = <WHERE> { appendToken(sb, t); } ] GroupGraphPattern(sb)
}

void BindingsClause(StringBuilder sb) :
{ Token t; }
{
    t = <BINDINGS> { appendToken(sb, t); }
    ( Var(sb) )* 
    t = <LBRACE> { appendToken(sb, t); }
	( BindingSet(sb))* 
    t = <RBRACE> { appendToken(sb, t); }
}

void BindingSet(StringBuilder sb) :
{ Token t; }
{
    LParen(sb)
	( BindingValue(sb) )* 
    RParen(sb)
    | 
    t = <NIL> { appendToken(sb, t); }
}

void BindingValue(StringBuilder sb) :
{ Token t; }
{
	IRIref(sb)
|	RDFLiteral(sb)
|	NumericLiteral(sb)
|	BooleanLiteral(sb)
|	t = <UNDEF> {appendToken(sb, t); }
}

void SolutionModifier(StringBuilder sb) #void :
{}
{
    [GroupClause(sb)] [HavingClause(sb)] [OrderClause(sb)] [LimitOffsetClauses(sb)]
}

void GroupClause(StringBuilder sb) :
{ Token t; }
{
    t = <GROUP> { appendToken(sb, t); } 
    t = <BY> {appendToken(sb, t); }
    ( GroupCondition(sb) )+
}

void OrderClause(StringBuilder sb) :
{ Token t; }
{
	t = <ORDER> { appendToken(sb, t); }
	t = <BY> { appendToken(sb, t); } 
	( OrderCondition(sb) )+
}

void GroupCondition(StringBuilder sb) :
{ Token t; }
{
	FunctionCall(sb)
|	BuiltInCall(sb)
|	LParen(sb)
	    Expression(sb) [ t = <AS> { appendToken(sb, t); } Var(sb) ] 
	RParen(sb)
|	Var(sb)
}

void HavingClause(StringBuilder sb) :
{Token t;}
{
    t = <HAVING> {appendToken(sb, t); }
    Constraint(sb)
}

void OrderCondition(StringBuilder sb) :
{ Token t; }
{
	[ 
	    ( t = <ASC> 
	    | t = <DESC> {jjtThis.setAscending(false);}
	    )
	    {appendToken(sb, t); }
	]  BrackettedExpression(sb)
|	FunctionCall(sb)
|	BuiltInCall(sb)
|	Var(sb)
}

void LimitOffsetClauses(StringBuilder sb) #void :
{}
{
	Limit(sb) [ Offset(sb) ]
|
	Offset(sb) [ Limit(sb) ]
}

void Limit(StringBuilder sb) :
{ Token t; }
{
	t = <LIMIT> { appendToken(sb, t); }
	t = <INTEGER> { jjtThis.setValue(Long.parseLong(t.image)); appendToken(sb, t); }
}

void Offset(StringBuilder sb) :
{ Token t; }
{
	t = <OFFSET> { appendToken(sb, t); }
	t = <INTEGER> { jjtThis.setValue(Long.parseLong(t.image)); appendToken(sb, t); }
}

void GroupGraphPattern(StringBuilder sb) #GraphPatternGroup :
{ Token t; }
{
	t = <LBRACE>  {appendToken(sb, t); }
	(
	    SelectQuery(sb) 
	    | 
	    GraphPattern(sb)
	) 
	t = <RBRACE>  {appendToken(sb, t); }
}

void GraphPattern(StringBuilder sb) #void :
{ Token t; }
{
	[BasicGraphPattern(sb)] [ GraphPatternNotTriples(sb) [ t = <DOT> {appendToken(sb, t);} ] GraphPattern(sb) ]
}

void BasicGraphPattern(StringBuilder sb) :
{ Token t; }
{
	TriplesBlock(sb) ( FilterOrBind(sb) [t = <DOT> {appendToken(sb, t);}] [TriplesBlock(sb)] )*
|
	( FilterOrBind(sb) [t = <DOT> {appendToken(sb, t);} ] [TriplesBlock(sb)] )+
}

void FilterOrBind(StringBuilder sb) #void :
{}
{
    Filter(sb)
    |
    Bind(sb)
}


void TriplesBlock(StringBuilder sb) #void :
{Token t;}
{
	// Note: recursive rule rewriten to non-recursive rule, requires lookahead
	TriplesSameSubjectPath(sb) 
	( 
	    LOOKAHEAD(2) 
	    t = <DOT> { appendToken(sb, t); } 
	    TriplesSameSubjectPath(sb) 
	)* 
	[ t= <DOT> { appendToken(sb, t); } ]
}

void TriplesTemplate(StringBuilder sb) #void :
{Token t;}
{
	// Note: recursive rule rewriten to non-recursive rule, requires lookahead
	TriplesSameSubject(sb) 
	( 
	    LOOKAHEAD(2) 
	    t= <DOT> {appendToken(sb, t); }
	    TriplesSameSubject(sb) 
	)* 
	[ t = <DOT> {appendToken(sb, t); }]
}

void GraphPatternNotTriples(StringBuilder sb) #void :
{}
{
	OptionalGraphPattern(sb)
|	GroupOrUnionGraphPattern(sb)
|	GraphGraphPattern(sb)
|	MinusGraphPattern(sb)
|	ServiceGraphPattern(sb)
}

void OptionalGraphPattern(StringBuilder sb) :
{Token t;}
{
	// Note: does not refer GroupGraphPattern(null) because constraints are not limited
	// to the optional graph pattern, but can also reference the operator's LHS
	t = <OPTIONAL> { appendToken(sb, t); }
	t = <LBRACE> { appendToken(sb, t); } 
	(
	    SelectQuery(sb) 
	    | GraphPattern(sb)
	) 
	t = <RBRACE> { appendToken(sb, t); }
}

void GraphGraphPattern(StringBuilder sb) :
{Token t;}
{
	t = <GRAPH> { appendToken(sb, t); }
	VarOrIRIref(sb) 
	GroupGraphPattern(sb)
}

void GroupOrUnionGraphPattern(StringBuilder sb) #void :
{Token t;}
{
	GroupGraphPattern(sb) 
	[
	    t = <UNION> { appendToken(sb, t); }
	    GroupOrUnionGraphPattern(sb) #UnionGraphPattern(2) 
	]
}

void MinusGraphPattern(StringBuilder sb) :
{Token t;}
{
    t = <MINUS_SETOPER> {appendToken(sb, t);}
    GroupGraphPattern(sb)
}

void ServiceGraphPattern(StringBuilder sbParent) :
{ 
    StringBuilder sb = new StringBuilder();
    Token t; 
    String s;
}
{
    t = <SERVICE> { appendToken(sb, t); }
    [t = <SILENT> { jjtThis.setSilent(true); appendToken(sb, t); } ] 
    VarOrIRIref(sb) GroupGraphPattern(sb)

    { 
	jjtThis.setPatternString(sb.toString()); 
	if (sbParent != null) {
	    sbParent.append(sb);
	}
    }
}

void Filter(StringBuilder sb) #void :
{Token t;}
{
	t = <FILTER> {appendToken(sb, t); }
	Constraint(sb)
}

void Constraint(StringBuilder sb) :
{}
{
	BrackettedExpression(sb)
|	BuiltInCall(sb)
|	FunctionCall(sb)
}

void FunctionCall(StringBuilder sb) :
{}
{
	IRIref(sb) ArgList(sb)
}

void ArgList(StringBuilder sb) #void :
{Token t;}
{
	t = <NIL> { appendToken(sb, t); }
|
	LParen(sb)
	Expression(sb) 
	( 
	    t = <COMMA> { appendToken(sb, t); }
	    Expression(sb) 
	)* 
	RParen(sb)
}

void TriplesSameSubject(StringBuilder sb) :
{}
{
	VarOrTerm(sb) PropertyList(sb)
|
	TriplesNode(sb) [PropertyList(sb)]
}

void PropertyList(StringBuilder sb) :
{Token t;}
{
	Verb(sb) ObjectList(sb) 
	[ 
	    t = <SEMICOLON> {appendToken(sb, t); } 
	    [PropertyList(sb)] 
	]
}

void ObjectList(StringBuilder sb):
{Token t;}
{
	Object(sb) 
	( 
	    t = <COMMA> { appendToken(sb, t); }
	    Object(sb) 
	)*
}

void TriplesSameSubjectPath(StringBuilder sb) :
{}
{
    VarOrTerm(sb) PropertyListPath(sb)
    |
    TriplesNode(sb) [PropertyListPath(sb)]
}

void PropertyListPath(StringBuilder sb) :
{Token t;}
{
    (
	VerbPath(sb) 
	| 
	VerbSimple(sb)
    ) 
    ObjectList(sb) 
    (
	LOOKAHEAD(2) 
	t = <SEMICOLON> { appendToken(sb, t); }
	[PropertyListPath(sb)] 
    )*
}

void VerbPath(StringBuilder sb) #void :
{}
{
    Path(sb)
}

void Path(StringBuilder sb) #void :
{}
{
    PathAlternative(sb)
}

void PathAlternative(StringBuilder sb) :
{ Token t; }
{
    PathSequence(sb) 
    ( 
	t = <PIPE> { appendToken(sb, t); }
	PathSequence(sb) 
    )*
}

void PathSequence(StringBuilder sb) :
{Token t; }
{
    PathElt(sb) 
    ( 
	t = <SLASH> { appendToken(sb, t); }
	PathElt(sb) 
    )*
}

void PathElt(StringBuilder sb) :
{Token t;}
{
    [ t = <INVERSE> {jjtThis.setInverse(true); appendToken(sb, t); } ] 
    PathPrimary(sb) 
    [ PathMod(sb) ]
}

void PathPrimary(StringBuilder sb) #void :
{Token t;}
{
    IRIref(sb) 
    |
    t = <IS_A> { appendToken(sb, t); jjtThis.setValue(RDF.TYPE.toString()); } #IRI
    |
    t = <NOT> { appendToken(sb, t); }
    PathNegatedPropertySet(sb) 
    |
    LParen(sb)
	Path(sb) 
    t= <RPAREN> {appendToken(sb, t); }
}

void PathNegatedPropertySet(StringBuilder sb) #void :
{Token t;}
{
    PathOneInPropertySet(sb) 
    |
    LParen(sb)
    [ 
	PathOneInPropertySet(sb) 
	( 
	    t = <PIPE> {appendToken(sb, t); }
	    PathOneInPropertySet(sb) 
	)* 
    ]
    RParen(sb)
}

void PathOneInPropertySet(StringBuilder sb) :
{Token t;}
{
    IRIref(sb) 
    |
    t = <IS_A> { appendToken(sb, t); jjtThis.setValue(RDF.TYPE.toString()); } #IRI
    |
    t = <INVERSE> { appendToken(sb, t); jjtThis.setInverse(true); } 
    ( 
	IRIref(sb) 
	| 
	t = <IS_A> { appendToken(sb, t); jjtThis.setValue(RDF.TYPE.toString()); } #IRI 
    )
}

void PathMod(StringBuilder sb) :
{ Token min;
  Token max; 
  Token t;
}
{
    t = <STAR> 
    { 
	jjtThis.setLowerBound(0);
	jjtThis.setUpperBound(Long.MAX_VALUE);
	appendToken(sb, t);
    }
    |
    t = <QUESTION> 
    { 
	jjtThis.setLowerBound(0);
	jjtThis.setUpperBound(1); 
	appendToken(sb, t);
    }
    |
    t = <PLUS> 
    { 
	jjtThis.setLowerBound(1);
	jjtThis.setUpperBound(Long.MAX_VALUE);
	appendToken(sb, t);
    }
    |
    t = <LBRACE> {appendToken(sb, t);}
    ( 
	min = <INTEGER> 
	{
	    jjtThis.setLowerBound(Long.parseLong(min.image)); 
	    appendToken(sb, min);
	} 
	( 
	    t = <COMMA> {appendToken(sb, t);}
	    ( 
		t = <RBRACE> {appendToken(sb, t); }
		| 
		max = <INTEGER> 
		{
		    jjtThis.setUpperBound(Long.parseLong(max.image)); 
		    appendToken(sb, max);
		} 
		t = <RBRACE> {appendToken(sb, t); }
	    ) 
	    | 
	    t = <RBRACE> {appendToken(sb, t);} 
	) 
	| 
	t = <COMMA> {appendToken(sb, t); }
	max = <INTEGER> 
	{
	    jjtThis.setUpperBound(Long.parseLong(max.image)); 
	    appendToken(sb, max);
	} 
	t = <RBRACE> {appendToken(sb, t); }
    )
}

void VerbSimple(StringBuilder sb) #void :
{}
{
    Var(sb)
}

void Object(StringBuilder sb) #void :
{}
{
	GraphNode(sb)
}

void Verb(StringBuilder sb) #void :
{Token t;}
{
	VarOrIRIref(sb)
|
	t = <IS_A> { appendToken(sb, t); jjtThis.setValue(RDF.TYPE.toString()); } #IRI
}

void TriplesNode(StringBuilder sb) #void :
{}
{
	Collection(sb)
|
	BlankNodePropertyList(sb)
}

void BlankNodePropertyList(StringBuilder sb) :
{ Token t; }
{
	t = <LBRACK> {appendToken(sb, t); }
	    PropertyList(sb) 
	t = <RBRACK> {appendToken(sb, t); }
}

void Collection(StringBuilder sb) :
{ Token t; }
{
	LParen(sb)
	( GraphNode(sb) )+ 
	RParen(sb)
}

void GraphNode(StringBuilder sb) #void :
{}
{
	VarOrTerm(sb)
|
	TriplesNode(sb)
}

void VarOrTerm(StringBuilder sb) #void :
{}
{
	Var(sb)
|
	GraphTerm(sb)
}

void VarOrIRIref(StringBuilder sb) #void :
{ 
}
{
	Var(sb)
|
 	IRIref(sb)
}

void Var(StringBuilder sb) :
{ Token t; }
{
	( t = <VAR1> | t = <VAR2> )
	{ 
	  jjtThis.setName(t.image.substring(1)); 
	  appendToken(sb, t);
	}
}

void GraphTerm(StringBuilder sb) #void :
{
	Token t;
	boolean positive = true;
}
{
	IRIref(sb)
|
	RDFLiteral(sb)
|
	NumericLiteral(sb)
|
	BooleanLiteral(sb)
|
	BlankNode(sb)
|
	t = <NIL> 
	{ 
	    appendToken(sb, t);
	    jjtThis.setValue(RDF.NIL.toString());
	} #IRI
}

void Expression(StringBuilder sb) #void :
{}
{
	ConditionalOrExpression(sb)
}

void ConditionalOrExpression(StringBuilder sb) #void :
{Token t; }
{
	ConditionalAndExpression(sb) 
	[ 
	    t = <OR> { appendToken(sb, t); }
	    ConditionalOrExpression(sb) #Or(2) 
	]
}

void ConditionalAndExpression(StringBuilder sb) #void :
{Token t; }
{
	ValueLogical(sb) 
	[ 
	    t = <AND> { appendToken(sb, t); }
	    ConditionalAndExpression(sb) #And(2) 
	]
}

void ValueLogical(StringBuilder sb) #void :
{}
{
	RelationalExpression(sb)
}

void RelationalExpression(StringBuilder sb) #void :
{Token t; }
{
	NumericExpression(sb)
	[
		t = <EQ> {appendToken(sb, t);}
		NumericExpression(sb) {jjtThis.setOperator(CompareOp.EQ);} #Compare(2)
	|	t = <NE> {appendToken(sb, t);}
		NumericExpression(sb) {jjtThis.setOperator(CompareOp.NE);} #Compare(2)
	|	t = <LT> {appendToken(sb, t);}
		NumericExpression(sb) {jjtThis.setOperator(CompareOp.LT);} #Compare(2)
	|	t = <LE> {appendToken(sb, t);}
		NumericExpression(sb) {jjtThis.setOperator(CompareOp.LE);} #Compare(2)
	|	t = <GE> {appendToken(sb, t);}
		NumericExpression(sb) {jjtThis.setOperator(CompareOp.GE);} #Compare(2)
	|	t = <GT> {appendToken(sb, t);}
		NumericExpression(sb) {jjtThis.setOperator(CompareOp.GT);} #Compare(2)
	|	In(sb) #Infix(2)
	|	NotIn(sb) #Infix(2)
	]
}

void NumericExpression (StringBuilder sb) #void :
{}
{
	AdditiveExpression(sb)
}

void AdditiveExpression(StringBuilder sb) #void :
{ Token t; }
{
	MultiplicativeExpression(sb)
	(
	  t = <PLUS> {appendToken(sb, t); }
	  MultiplicativeExpression(sb) {jjtThis.setOperator(MathOp.PLUS);} #Math(2)
	| 
	  t= <MINUS> {appendToken(sb, t); }
	  MultiplicativeExpression(sb) {jjtThis.setOperator(MathOp.MINUS);} #Math(2)
	| NumericLiteralPositive(sb) {jjtThis.setOperator(MathOp.PLUS);} #Math(2)
	| NumericLiteralNegative(sb) {jjtThis.setOperator(MathOp.PLUS);} #Math(2)
	)*
}

void MultiplicativeExpression(StringBuilder sb) #void :
{ Token t; }
{
	UnaryExpression(sb)
	(
	  t = <STAR> {appendToken(sb, t); }
	  UnaryExpression(sb) {jjtThis.setOperator(MathOp.MULTIPLY);} #Math(2)
	| 
	  t = <SLASH> {appendToken(sb, t); }
	  UnaryExpression(sb) {jjtThis.setOperator(MathOp.DIVIDE);} #Math(2)
	)*
}

void UnaryExpression(StringBuilder sb) #void :
{ Token t; }
{
	t = <NOT> { appendToken(sb, t); } 
	PrimaryExpression(sb) #Not
|
	[ t= <PLUS> {appendToken(sb, t);} ] 
	PrimaryExpression(sb)
|
	UnaryMinus(sb) PrimaryExpression(sb) {jjtThis.setOperator(MathOp.MULTIPLY);} #Math(2)
}

void UnaryMinus(StringBuilder sb) #NumericLiteral :
{ Token t; }
{
	t = <MINUS> 
	{	
		appendToken(sb, t); 
		jjtThis.setValue("-1");
		jjtThis.setDatatype(XMLSchema.INTEGER);
	}
}

void PrimaryExpression(StringBuilder sb) #void :
{}
{
	BrackettedExpression(sb)
|	BuiltInCall(sb)
|	LOOKAHEAD(2) FunctionCall(sb)
|	IRIref(sb)
|	RDFLiteral(sb)
|	NumericLiteral(sb)
|	BooleanLiteral(sb)
|	Var(sb)
| 	Aggregate(sb)
}

void Aggregate(StringBuilder sb) #void :
{}
{
    Count(sb) 
|   Sum(sb)
|   Min(sb)
|   Max(sb)
|   Avg(sb)
|   Sample(sb)
|   GroupConcat(sb)
}

void Count(StringBuilder sb) :
{Token t;}
{
    t = <COUNT> { appendToken(sb, t); }
    LParen(sb)
	[ t = <DISTINCT> { appendToken(sb, t); jjtThis.setDistinct(true); } ]
	( 
	    t = <STAR> { appendToken(sb, t); jjtThis.setWildcard(true); } 
	    | 
	    Expression(sb)
	) 
    RParen(sb)
}

void LParen(StringBuilder sb) #void : 
{ Token t; }
{
    t = <LPAREN> { appendToken(sb, t); }
}

void RParen(StringBuilder sb) #void : 
{ Token t; }
{
    t = <RPAREN> { appendToken(sb, t); }
}


void Sum(StringBuilder sb) :
{Token t;}
{
    t = <SUM> {appendToken(sb, t);}
    LParen(sb)
	[ t = <DISTINCT> { appendToken(sb, t); jjtThis.setDistinct(true); } ] 
	Expression(sb) 
    RParen(sb)
}

void Min(StringBuilder sb) :
{Token t;}
{
    t = <MIN> {appendToken(sb, t); }
    LParen(sb) 
	[ t = <DISTINCT> { appendToken(sb, t); jjtThis.setDistinct(true); } ] 
	Expression(sb) 
    RParen(sb)
}

void Max(StringBuilder sb) :
{Token t;}
{
    t = <MAX> { appendToken(sb, t); }
    LParen(sb)
	[ t = <DISTINCT> { appendToken(sb, t); jjtThis.setDistinct(true); } ] 
	Expression(sb) 
    RParen(sb)
}

void Avg(StringBuilder sb) :
{Token t;}
{
    t = <AVG> {appendToken(sb, t); }
    LParen(sb) 
	[ t = <DISTINCT> { appendToken(sb, t); jjtThis.setDistinct(true); } ] 
	Expression(sb) 
    RParen(sb)
}

void Sample(StringBuilder sb) :
{Token t;}
{
    t = <SAMPLE> {appendToken(sb, t); }
    LParen(sb)
	[ t = <DISTINCT> { appendToken(sb, t); jjtThis.setDistinct(true); } ] Expression(sb) 
    RParen(sb)
}

void GroupConcat(StringBuilder sb) :
{Token t;}
{
    t = <GROUP_CONCAT> {appendToken(sb, t); }
    LParen(sb)
	[ t = <DISTINCT> { appendToken(sb, t); jjtThis.setDistinct(true); } ] Expression(sb) 
	[ 
	    t = <SEMICOLON> { appendToken(sb, t); }
	    t = <SEPARATOR> { appendToken(sb, t); }
	    t = <EQ> {appendToken(sb, t); }
	    Expression(sb) 
	]
    RParen(sb)
}

void BrackettedExpression(StringBuilder sb) #void :
{}
{
	LParen(sb)
	    Expression(sb) 
	RParen(sb)
}

void BuiltInCall(StringBuilder sb) #void :
{}
{
	Bound(sb)
|	SameTerm(sb)
|	ExistsFunc(sb)
|	NotExistsFunc(sb)
|	Coalesce(sb)
|	If(sb)
|	StringFunction(sb)
|	NumericFunction(sb)
|	RDFTermFunction(sb)
|	DateTimeFunction(sb)
|	HashFunction(sb)
}

void StringFunction(StringBuilder sb) #void :
{}
{
	Substr(sb)
|	StrLen(sb)
|	UpperCase(sb)
|	LowerCase(sb)
|	StrStarts(sb)
|	StrEnds(sb)
|	Concat(sb)
|	Contains(sb)
|	EncodeForURI(sb)
|	LangMatches(sb)
|	RegexExpression(sb)
}
void NumericFunction(StringBuilder sb) #void :
{}
{
	Rand(sb)
|	Abs(sb)
|	Ceil(sb)
|	Floor(sb)
|	Round(sb)
}

void RDFTermFunction(StringBuilder sb) #void :
{}
{
	IsIRI(sb)
|	IsBlank(sb)
|	IsLiteral(sb)
|	IsNumeric(sb)
|	BNodeFunc(sb)
|	IRIFunc(sb)
|	Lang(sb)
|	Datatype(sb)
|	Str(sb)
|	StrDt(sb)
|	StrLang(sb)
}

void DateTimeFunction(StringBuilder sb) #void :
{}
{
	Now(sb)
|	Year(sb)
|	Month(sb)
|	Day(sb)
|	Hours(sb)
|	Minutes(sb)
|	Seconds(sb)
|	Timezone(sb)
|	Tz(sb)
}

void HashFunction(StringBuilder sb) #void :
{}
{
	MD5(sb)
|	SHA1(sb)
|	SHA224(sb)
|	SHA256(sb)
|	SHA384(sb)
|	SHA512(sb)
}


void MD5(StringBuilder sb) :
{Token t;}
{
    t = <MD5> { appendToken(sb, t); }
    BrackettedExpression(sb)
}

void SHA1(StringBuilder sb) :
{Token t;}
{
    t = <SHA1> { appendToken(sb, t); }
    BrackettedExpression(sb)
}

void SHA224(StringBuilder sb) :
{Token t; }
{
    t = <SHA224> { appendToken(sb, t); } 
    BrackettedExpression(sb)
}

void SHA256(StringBuilder sb) :
{Token t;}
{
    t = <SHA256> { appendToken(sb, t); }
    BrackettedExpression(sb)
}

void SHA384(StringBuilder sb) :
{Token t;}
{
    t = <SHA384> { appendToken(sb, t); }
    BrackettedExpression(sb)
}

void SHA512(StringBuilder sb) :
{Token t;}
{
    t = <SHA512> { appendToken(sb, t); }
    BrackettedExpression(sb)
}

void Now(StringBuilder sb) :
{Token t;}
{
    t = <NOW> { appendToken(sb, t); }
    t = <NIL> { appendToken(sb, t); }
}

void Year(StringBuilder sb) :
{Token t;}
{
    t = <YEAR> { appendToken(sb, t); }
    BrackettedExpression(sb)
}

void Month(StringBuilder sb) :
{Token t;}
{
    t = <MONTH> { appendToken(sb, t); }
    BrackettedExpression(sb)
}

void Day(StringBuilder sb) :
{Token t;}
{
    t = <DAY> { appendToken(sb, t); }
    BrackettedExpression(sb)
}

void Hours(StringBuilder sb) :
{Token t;}
{
    t = <HOURS> { appendToken(sb, t); }
    BrackettedExpression(sb)
}

void Minutes(StringBuilder sb) :
{Token t;}
{
    t = <MINUTES> { appendToken(sb, t); } 
    BrackettedExpression(sb)
}

void Seconds(StringBuilder sb) :
{Token t;}
{
    t = <SECONDS> { appendToken(sb, t); }
    BrackettedExpression(sb)
}

void Timezone(StringBuilder sb) :
{Token t;}
{
    t = <TIMEZONE> { appendToken(sb, t); }
    BrackettedExpression(sb)
}

void Tz(StringBuilder sb) :
{Token t;}
{
    t = <TZ> { appendToken(sb, t); }
    BrackettedExpression(sb)
}

void Rand(StringBuilder sb) :
{Token t;}
{
    t= <RAND> { appendToken(sb, t); }
    t = <NIL> { appendToken(sb, t); }
}

void Abs(StringBuilder sb) :
{Token t;}
{
    t = <ABS> { appendToken(sb, t); }
    BrackettedExpression(sb)
}

void Ceil(StringBuilder sb) :
{Token t;}
{
    t = <CEIL> { appendToken(sb, t); }
    BrackettedExpression(sb)
}

void Floor(StringBuilder sb) :
{Token t;}
{
    t = <FLOOR> { appendToken(sb, t); }
    BrackettedExpression(sb)
}

void Round(StringBuilder sb) :
{Token t;}
{
    t = <ROUND> { appendToken(sb, t); }
    BrackettedExpression(sb)
}

void Substr(StringBuilder sb) :
{Token t;}
{
    t = <SUBSTR> { appendToken(sb, t); }
    LParen(sb)
	Expression(sb) 
	t = <COMMA> { appendToken(sb, t); }
	Expression(sb) 
	[ 
	    t = <COMMA> { appendToken(sb, t); } 
	    Expression(sb) 
	]
    RParen(sb)
}

void StrLen(StringBuilder sb) :
{Token t;}
{
    t= <STRLEN> { appendToken(sb, t); }
    BrackettedExpression(sb)
}

void UpperCase(StringBuilder sb) :
{Token t;}
{
    t = <UCASE> { appendToken(sb, t); }
    BrackettedExpression(sb)
}

void LowerCase(StringBuilder sb) :
{Token t;}
{
    t = <LCASE> { appendToken(sb, t); }
    BrackettedExpression(sb)
}

void StrStarts(StringBuilder sb) :
{Token t;}
{
    t = <STR_STARTS> { appendToken(sb, t); }
    LParen(sb) 
	Expression(sb) 
	t = <COMMA> { appendToken(sb, t); }
	Expression(sb) 
    RParen(sb)
}

void StrEnds(StringBuilder sb) :
{Token t;}
{
    t = <STR_ENDS> { appendToken(sb, t); } 
    LParen(sb)
	Expression(sb) 
	t = <COMMA> { appendToken(sb, t); }
	Expression(sb) 
    RParen(sb)
}

void Concat(StringBuilder sb) :
{Token t;}
{
    t = <CONCAT> { appendToken(sb, t); }
    ArgList(sb)
}

void Contains(StringBuilder sb) :
{Token t;}
{
    t = <CONTAINS> { appendToken(sb, t); }
    LParen(sb)
	Expression(sb) 
	t = <COMMA> { appendToken(sb, t); } 
	Expression(sb) 
    RParen(sb)
}

void EncodeForURI(StringBuilder sb) :
{Token t;}
{
    t = <ENCODE_FOR_URI> { appendToken(sb, t); }
    BrackettedExpression(sb)
}

void Comma(StringBuilder sb) #void :
{Token t;}
{
    t = <COMMA> { appendToken(sb, t); }
}

void If(StringBuilder sb) :
{Token t;}
{
    t = <IF> { appendToken(sb, t); }
    LParen(sb)
	Expression(sb) 
	Comma(sb)
	Expression(sb) 
	Comma(sb) 
	Expression(sb)
    RParen(sb)
}

void In(StringBuilder sb) :
{Token t;}
{
    t = <IN> { appendToken(sb, t); }
    ArgList(sb)
}

void NotIn(StringBuilder sb) :
{Token t;}
{
    t = <NOT_IN> { appendToken(sb, t); }
    ArgList(sb)
}

void Coalesce(StringBuilder sb) : 
{Token t;}
{
    t = <COALESCE> { appendToken(sb, t); }
    LParen(sb)
	Expression(sb) 
	(
	    Comma(sb) 
	    Expression(sb)
	)* 
    RParen(sb)
}

void Str(StringBuilder sb) :
{Token t;}
{
	t = <STR> { appendToken(sb, t); }
	BrackettedExpression(sb)
}

void Lang(StringBuilder sb) :
{Token t;}
{
	t = <LANG> { appendToken(sb, t); }
	BrackettedExpression(sb)
}

void LangMatches(StringBuilder sb) :
{Token t;}
{
	t = <LANGMATCHES> { appendToken(sb, t); }
	LParen(sb)
	    Expression(sb) 
	    Comma(sb)
	    Expression(sb) 
	RParen(sb)
}

void Datatype(StringBuilder sb) :
{Token t;}
{
	t = <DATATYPE> { appendToken(sb, t); }
	BrackettedExpression(sb)
}

void Bound(StringBuilder sb) :
{Token t;}
{
	t = <BOUND> { appendToken(sb, t); }
	LParen(sb) 
	    Var(sb) 
	RParen(sb)
}

void SameTerm(StringBuilder sb) :
{Token t;}
{
	t = <SAMETERM> { appendToken(sb, t); }
	LParen(sb)
	    Expression(sb) 
	    Comma(sb)
	    Expression(sb) 
	RParen(sb)
}

void IsIRI(StringBuilder sb) :
{Token t;}
{
	t = <IS_IRI> { appendToken(sb, t); }
	BrackettedExpression(sb)
}

void IsBlank(StringBuilder sb) :
{Token t;}
{
	t = <IS_BLANK> { appendToken(sb, t); }
	BrackettedExpression(sb)
}

void IsLiteral(StringBuilder sb) :
{Token t;}
{
	t = <IS_LITERAL> { appendToken(sb, t); }
	BrackettedExpression(sb)
}

void IsNumeric(StringBuilder sb) :
{Token t;}
{
	t = <IS_NUMERIC> { appendToken(sb, t); }
	BrackettedExpression(sb)
}

void BNodeFunc(StringBuilder sb) :
{Token t;}
{
	t = <BNODE> { appendToken(sb, t); }
	( 
	    t  = <NIL> { appendToken(sb, t); }
	    | 
	    LParen(sb) 
		Expression(sb) 
	    RParen(sb) 
	) 
}

void IRIFunc(StringBuilder sb) :
{Token t;}
{
	t = <IRI> { appendToken(sb, t); }
	BrackettedExpression(sb)
}

void StrDt(StringBuilder sb) :
{Token t;}
{
	t = <STRDT> { appendToken(sb, t); }
	LParen(sb)
	    Expression(sb) 
	    Comma(sb) 
	    Expression(sb)
	RParen(sb)
}

void StrLang(StringBuilder sb) :
{Token t;}
{
	t = <STRLANG> { appendToken(sb, t); }
	LParen(sb)
	    Expression(sb) 
	    Comma(sb)
	    Expression(sb)
	RParen(sb)
}

void Bind(StringBuilder sb) :
{Token t;}
{
	t = <BIND> { appendToken(sb, t); }
	LParen(sb)
	    Expression(sb) 
	    t = <AS> { appendToken(sb, t); } 
	    Var(sb) 
	RParen(sb)
}

void RegexExpression(StringBuilder sb) :
{Token t;}
{
	t = <REGEX> { appendToken(sb, t); }
	LParen(sb)
	    Expression(sb) 
	    Comma(sb)
	    Expression(sb) 
	    [ 
		Comma(sb)
		Expression(sb) 
	    ]
	RParen(sb)
}

void ExistsFunc(StringBuilder sb) :
{Token t;}
{
    t = <EXISTS> { appendToken(sb, t); } 
    GroupGraphPattern(sb)
}

void NotExistsFunc(StringBuilder sb) :
{Token t;}
{
    t = <NOT_EXISTS> { appendToken(sb, t); }
    GroupGraphPattern(sb)
}


void RDFLiteral(StringBuilder sb) :
{ Token t; }
{
	String(sb)
	[
		t = <LANGTAG> {appendToken(sb, t); jjtThis.setLang(t.image.substring(1));}
	|
		t = <DT_PREFIX> {appendToken(sb, t);}
		IRIref(sb)
	]
}

void NumericLiteral(StringBuilder sb) #void :
{}
{
	(
		NumericLiteralUnsigned(sb)
	|	NumericLiteralPositive(sb)
	|	NumericLiteralNegative(sb)
	)
}

void NumericLiteralUnsigned(StringBuilder sb) #NumericLiteral :
{ Token t; URI datatype; }
{
	(
		t = <INTEGER> { datatype = XMLSchema.INTEGER; }
	|	t = <DECIMAL> { datatype = XMLSchema.DECIMAL; }
	|	t = <DOUBLE> { datatype = XMLSchema.DOUBLE; }
	)

	{
		jjtThis.setValue(t.image);
		jjtThis.setDatatype(datatype);
		appendToken(sb, t); 
	}
}

void NumericLiteralPositive(StringBuilder sb) #NumericLiteral :
{ Token t; URI datatype; }
{
	(
		t = <INTEGER_POSITIVE> { datatype = XMLSchema.INTEGER; }
	|	t = <DECIMAL_POSITIVE> { datatype = XMLSchema.DECIMAL; }
	|	t = <DOUBLE_POSITIVE> { datatype = XMLSchema.DOUBLE; }
	)

	{
		jjtThis.setValue(t.image);
		jjtThis.setDatatype(datatype);
		appendToken(sb, t);
	}
}

void NumericLiteralNegative(StringBuilder sb) #NumericLiteral :
{ Token t; URI datatype; }
{
	(
		t = <INTEGER_NEGATIVE> { datatype = XMLSchema.INTEGER; }
	|	t = <DECIMAL_NEGATIVE> { datatype = XMLSchema.DECIMAL; }
	|	t = <DOUBLE_NEGATIVE> { datatype = XMLSchema.DOUBLE; }
	)

	{
		jjtThis.setValue(t.image);
		jjtThis.setDatatype(datatype);
		appendToken(sb, t);
	}
}

void BooleanLiteral(StringBuilder sb) #void :
{Token t;}
{
    (
	t = <TRUE> #True
	|
	t = <FALSE> #False
    )
    { appendToken(sb, t); }
}

void String(StringBuilder sb) :
{ Token t; }
{
	( t = <STRING_LITERAL1> | t= <STRING_LITERAL2> )
	{jjtThis.setValue(_trimString(t.image, 1)); appendToken(sb, t); }
|
	( t = <STRING_LITERAL_LONG1> | t = <STRING_LITERAL_LONG2>)
	{jjtThis.setValue(_trimString(t.image, 3)); appendToken(sb, t); }
}

void IRIref(StringBuilder sb) #void :
{ }
{

	IRI(sb)
|
	PrefixedName(sb)
}

void PrefixedName(StringBuilder sb) #QName :
{ Token t; }
{
	(t = <PNAME_LN> | t = <PNAME_NS>)
	{
	    jjtThis.setValue(t.image);
	    appendToken(sb, t);
	}
}


void BlankNode(StringBuilder sb) :
{ Token t; }
{
(
	t = <BLANK_NODE_LABEL> {jjtThis.setID(t.image.substring(2)); }
|
	t= <ANON> 
)
    { appendToken(sb, t); }
}

void IRI(StringBuilder sb) :
{ Token t; }
{
	t = <Q_IRI_REF> {jjtThis.setValue(_trimString(t.image, 1)); appendToken(sb, t); }
}

/// SPARQL 1.1 Update productions

void GraphRefAll() :
{}
{
	GraphRef() 
|	<DEFAULT_GRAPH> {jjtThis.setDefault(true); }
|	<NAMED> 	{jjtThis.setNamed(true); }
|	<ALL>
}

void GraphOrDefault() :
{}
{
	<DEFAULT_GRAPH>
|	[<GRAPH>] IRIref(null)
}

void GraphRef() #void :
{}
{ 
	<GRAPH> IRIref(null) 
}

void QuadData() #void :
{}
{
    <LBRACE> Quads() <RBRACE> 
}

void Quads() #void :
{}
{
    [TriplesTemplate(null)] ( QuadsNotTriples() [<DOT>] [TriplesTemplate(null)] )*
}

void QuadsNotTriples() :
{}
{
    <GRAPH> VarOrIRIref(null) <LBRACE> [TriplesTemplate(null)] <RBRACE>
}

void Update() #void :
{}
{
	Load()
|	Clear()
|	Drop()
|	Add()
|	Move()
|	Copy()
|	Create()
|	LOOKAHEAD(2) InsertData()
|	LOOKAHEAD(2) DeleteData() 
|	LOOKAHEAD(2) DeleteWhere()
|	Modify()
}

void Load() :
{}
{
    <LOAD> [<SILENT> {jjtThis.setSilent(true);} ] IRIref(null) [<INTO> GraphRef() ]
}


void Clear() :
{}
{
	<CLEAR> [<SILENT> {jjtThis.setSilent(true);} ] GraphRefAll()
}

void Drop() :
{}
{
	<DROP> [<SILENT> {jjtThis.setSilent(true);} ] GraphRefAll()
}

void Add() :
{}
{
	<ADD> [<SILENT> {jjtThis.setSilent(true);} ] GraphOrDefault() <TO> GraphOrDefault()
}

void Move() :
{}
{
	<MOVE> [<SILENT> {jjtThis.setSilent(true);} ] GraphOrDefault() <TO> GraphOrDefault()
}

void Copy() :
{}
{
	<COPY> [<SILENT> {jjtThis.setSilent(true);} ] GraphOrDefault() <TO> GraphOrDefault()
}

void Create() :
{}
{
	<CREATE> [<SILENT> {jjtThis.setSilent(true);} ] GraphRef()
}

void InsertData() :
{}
{
    <INSERT> <DATA> QuadData()
}

void DeleteData() :
{}
{
    <DELETE> <DATA> QuadData()
}

void DeleteWhere() :
{}
{
    <DELETE> <WHERE> QuadData()
}

void DeleteClause() :
{}
{
    <DELETE> QuadData()
}

void InsertClause() :
{}
{
    <INSERT> QuadData()
}

void UsingClause() #DatasetClause :
{}
{
    <USING> [<NAMED> {jjtThis.setNamed(true);}] IRIref(null)
}

void Modify() :
{}
{
    [<WITH> IRIref(null)] 
    ( DeleteClause() [InsertClause()] | InsertClause() ) (UsingClause())* 
    <WHERE> GroupGraphPattern(null)
}
